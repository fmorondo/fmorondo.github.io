<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Teletipos â†’ HTML para Xalok Â· Diario de Navarra</title>
  <meta name="description" content="Pega un teletipo y copia automÃ¡ticamente el HTML con pÃ¡rrafos para Xalok." />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <meta name="robots" content="noindex, nofollow">
</head>

<body>
  <header>
    <div class="brand">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none"
        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M12 20V10"></path><path d="M18 20V4"></path><path d="M6 20v-4"></path>
      </svg>
      Diario de Navarra Â· Utilidades
      <span class="badge">Xalok</span>
    </div>
  </header>

  <main>
    <section class="card stack" aria-labelledby="titulo">
      <div class="stack" style="gap:6px">
        <h1 id="titulo" class="title">ğŸ“° Teletipos â†’ HTML para Xalok</h1>
        <p class="subtitle">
          Pega el teletipo. El sistema reconstruye pÃ¡rrafos si es necesario, genera el cÃ³digo HTML (<code>&lt;p&gt;...&lt;/p&gt;</code>)
          y lo copia al portapapeles automÃ¡ticamente. Si tu navegador lo bloquea, usa el botÃ³n â€œCopiar HTMLâ€.
        </p>
      </div>

      <details>
        <summary>ğŸ“˜ CÃ³mo usar</summary>
        <div class="panel">
          <ol style="margin:0; padding-left:18px;">
            <li>Pega el teletipo en la caja.</li>
            <li>Si ves el mensaje â€œCopiado âœ…â€, pega directamente en Xalok.</li>
            <li>Si aparece â€œPulsa Copiar HTMLâ€, haz clic en el botÃ³n y vuelve a pegar en Xalok.</li>
          </ol>
        </div>
      </details>

      <div class="stack">
        <label for="input">Teletipo (pega aquÃ­):</label>
        <textarea id="input" class="result" style="min-height: 220px;" placeholder="Pega aquÃ­ el teletipo..."></textarea>
      </div>

      <div class="row">
        <button id="copyBtn" type="button" class="hidden">ğŸ“‹ Copiar HTML</button>
        <button id="limpiar" type="button" class="btn-secondary">Limpiar</button>
      </div>

      <div class="stack">
        <h3 style="margin:8px 0 0 0">Estado</h3>
        <pre id="status" class="result">Esperando teletipo...</pre>
        <!-- Salida oculta: la mantenemos para depurar si hiciera falta -->
        <textarea id="htmlOut" class="result hidden" style="min-height: 160px;"></textarea>
        <p class="footer">Si el teletipo viene â€œaplanadoâ€, se intenta reconstruir desde <em>text/html</em> del portapapeles.</p>
      </div>
    </section>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);

    const input = $("input");
    const status = $("status");
    const htmlOut = $("htmlOut");
    const copyBtn = $("copyBtn");
    const limpiarBtn = $("limpiar");

    // ---- NormalizaciÃ³n bÃ¡sica ----
    function normalize(text) {
      text = (text || "");
      text = text.replace(/\r\n?/g, "\n");          // CRLF/CR -> LF
      text = text.replace(/\u2028|\u2029/g, "\n");  // separadores unicode
      text = text.replace(/^\uFEFF/, "");           // BOM
      text = text.replace(/\u00A0/g, " ");          // NBSP
      return text;
    }

    function escapeHtml(s) {
      return s
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // ---- ReconstrucciÃ³n desde HTML del portapapeles (si el plain viene â€œaplanadoâ€) ----
    function htmlClipboardToText(html) {
      const tmp = document.createElement("div");
      tmp.style.position = "fixed";
      tmp.style.left = "-9999px";
      tmp.style.top = "0";
      tmp.style.whiteSpace = "pre-wrap";
      tmp.innerHTML = html;

      // br -> salto
      tmp.querySelectorAll("br").forEach(br => br.replaceWith("\n"));

      // fuerza separaciÃ³n para elementos de bloque tÃ­picos
      const blockSel = "p,div,li,ul,ol,table,tr,blockquote,h1,h2,h3,h4,h5,h6";
      tmp.querySelectorAll(blockSel).forEach(el => {
        el.appendChild(document.createTextNode("\n\n"));
      });

      document.body.appendChild(tmp);
      const text = tmp.innerText;
      tmp.remove();
      return normalize(text);
    }

    // ---- SegmentaciÃ³n â€œAutoâ€ de pÃ¡rrafos (sin selector) ----
    // - Si hay lÃ­neas en blanco -> pÃ¡rrafos por lÃ­nea en blanco
    // - Si NO las hay -> cada salto de lÃ­nea es un pÃ¡rrafo
    function splitParagraphsAuto(text) {
      text = normalize(text).trim();
      if (!text) return [];

      const hasBlankLines = /\n[ \t]*\n+/.test(text);
      const parts = hasBlankLines ? text.split(/\n[ \t]*\n+/) : text.split(/\n+/);
      return parts.map(p => p.trim()).filter(Boolean);
    }

    // ---- GeneraciÃ³n HTML literal para Xalok ----
    function toXalokHtmlLiteral(text) {
      const paras = splitParagraphsAuto(text);

      // Importante: NO â€œunwrapâ€ agresivo aquÃ­, porque en modo â€œcada salto = pÃ¡rrafoâ€
      // ya consideramos que el salto define el pÃ¡rrafo.
      // Si hay lÃ­neas en blanco, dentro de cada pÃ¡rrafo podrÃ­a haber hard-wrap;
      // en ese caso unimos saltos simples internos a espacio.
      const source = normalize(text);
      const hasBlankLines = /\n[ \t]*\n+/.test(source);

      const htmlParas = paras.map(p => {
        if (hasBlankLines) {
          p = p.replace(/\n+/g, " ").replace(/[ \t]{2,}/g, " ").trim();
        }
        return `<p>${escapeHtml(p)}</p>`;
      });

      return htmlParas.join("\n\n");
    }

    async function copyHtmlToClipboard(html) {
      // Copiamos como TEXTO (cÃ³digo literal), que es lo que nos has indicado que Xalok acepta.
      await navigator.clipboard.writeText(html);
    }

    function setStatus(msg, isError = false) {
      status.textContent = msg;
      status.className = "result";
      if (isError) {
        status.style.borderColor = "#ef4444";
        status.style.color = "#b91c1c";
        status.style.backgroundColor = "#fef2f2";
      } else {
        status.style.borderColor = "";
        status.style.color = "";
        status.style.backgroundColor = "";
      }
    }

    async function transformAndMaybeCopy() {
      const raw = input.value || "";
      const html = toXalokHtmlLiteral(raw);
      htmlOut.value = html;

      if (!html.trim()) {
        copyBtn.classList.add("hidden");
        setStatus("Esperando teletipo...");
        return;
      }

      try {
        await copyHtmlToClipboard(html);
        copyBtn.classList.add("hidden");
        setStatus("âœ… Copiado al portapapeles. Pega en Xalok.");
      } catch (e) {
        // FallÃ³ por permisos/polÃ­tica: mostramos botÃ³n para gesto explÃ­cito
        copyBtn.classList.remove("hidden");
        setStatus("âš ï¸ No se pudo copiar automÃ¡ticamente. Pulsa â€œCopiar HTMLâ€ y despuÃ©s pega en Xalok.");
      }
    }

    // 1) Al pegar: intentamos reconstruir bien el texto (si viene â€œaplanadoâ€) y copiamos HTML automÃ¡ticamente
    input.addEventListener("paste", async (e) => {
      const cd = e.clipboardData;
      if (!cd) return;

      const plain = normalize(cd.getData("text/plain") || "");
      const html = cd.getData("text/html") || "";

      const plainHasBreaks = /[\n\r\u2028\u2029]/.test(plain);

      // Si el plain viene â€œaplanadoâ€ pero hay HTML, reconstruimos el texto desde HTML
      if (!plainHasBreaks && html) {
        e.preventDefault();
        const reconstructed = htmlClipboardToText(html);

        const start = input.selectionStart ?? input.value.length;
        const end = input.selectionEnd ?? input.value.length;
        input.value = input.value.slice(0, start) + reconstructed + input.value.slice(end);

        const pos = start + reconstructed.length;
        input.setSelectionRange(pos, pos);
      }

      // Espera al siguiente tick para asegurar que el textarea contiene el texto final
      setTimeout(() => { transformAndMaybeCopy(); }, 0);
    });

    // 2) BotÃ³n fallback: genera + copia con gesto explÃ­cito (si el auto-copy falla)
    copyBtn.addEventListener("click", async () => {
      const html = toXalokHtmlLiteral(input.value || "");
      htmlOut.value = html;

      try {
        await copyHtmlToClipboard(html);
        copyBtn.classList.add("hidden");
        setStatus("âœ… Copiado al portapapeles. Pega en Xalok.");
      } catch (e) {
        setStatus("âŒ Tu navegador bloquea el portapapeles. Selecciona el HTML (modo tÃ©cnico) y Ctrl+C.", true);
        // Si alguna vez necesitÃ¡is ese fallback, desocultamos la caja para copiar manualmente:
        htmlOut.classList.remove("hidden");
        htmlOut.focus();
        htmlOut.select();
      }
    });

    // 3) Limpiar
    limpiarBtn.addEventListener("click", () => {
      input.value = "";
      htmlOut.value = "";
      htmlOut.classList.add("hidden");
      copyBtn.classList.add("hidden");
      setStatus("Esperando teletipo...");
      input.focus();
    });

    // Estado inicial
    setStatus("Esperando teletipo...");
  </script>
</body>
</html>
